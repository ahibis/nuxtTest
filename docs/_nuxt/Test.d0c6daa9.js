import{x,m as b,i as p,y as w,z as h,A as B,h as m,B as k,C as O,q as E,o as T,c as M,a as f,d as D,t as g}from"./entry.1f0db05a.js";const z=()=>null;function j(...r){const i=typeof r[r.length-1]=="string"?r.pop():void 0;typeof r[0]!="string"&&r.unshift(i);let[a,l,t={}]=r;if(typeof a!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");t.server=t.server??!0,t.default=t.default??z,t.lazy=t.lazy??!1,t.immediate=t.immediate??!0;const e=b(),d=()=>e.isHydrating?e.payload.data[a]:e.static.data[a],y=()=>d()!==void 0;e._asyncData[a]||(e._asyncData[a]={data:p(d()??t.default()),pending:p(!y()),error:x(e.payload._errors,a),status:p("idle")});const n={...e._asyncData[a]};n.refresh=n.execute=(o={})=>{if(e._asyncDataPromises[a]){if(o.dedupe===!1)return e._asyncDataPromises[a];e._asyncDataPromises[a].cancelled=!0}if((o._initial||e.isHydrating&&o._initial!==!1)&&y())return d();n.pending.value=!0,n.status.value="pending";const c=new Promise((s,u)=>{try{s(l(e))}catch(C){u(C)}}).then(s=>{if(c.cancelled)return e._asyncDataPromises[a];let u=s;t.transform&&(u=t.transform(s)),t.pick&&(u=N(u,t.pick)),n.data.value=u,n.error.value=null,n.status.value="success"}).catch(s=>{if(c.cancelled)return e._asyncDataPromises[a];n.error.value=s,n.data.value=m(t.default()),n.status.value="error"}).finally(()=>{c.cancelled||(n.pending.value=!1,e.payload.data[a]=n.data.value,n.error.value&&(e.payload._errors[a]=k(n.error.value)),delete e._asyncDataPromises[a])});return e._asyncDataPromises[a]=c,e._asyncDataPromises[a]};const v=()=>n.refresh({_initial:!0}),P=t.server!==!1&&e.payload.serverRendered;{const o=O();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const s=o._nuxtOnBeforeMountCbs;o&&(w(()=>{s.forEach(u=>{u()}),s.splice(0,s.length)}),h(()=>s.splice(0,s.length)))}P&&e.isHydrating&&y()?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):o&&(e.payload.serverRendered&&e.isHydrating||t.lazy)&&t.immediate?o._nuxtOnBeforeMountCbs.push(v):t.immediate&&v(),t.watch&&B(t.watch,()=>n.refresh());const c=e.hook("app:data:refresh",s=>{if(!s||s.includes(a))return n.refresh()});o&&h(c)}const _=Promise.resolve(e._asyncDataPromises[a]).then(()=>n);return Object.assign(_,n),_}function H(r){const i=b();return r in i.payload.data||(i.payload.data[r]=null),{data:x(i.payload.data,r)}}function N(r,i){const a={};for(const l of i)a[l]=r[l];return a}const S=f("h2",null,"TEST",-1),A={__name:"Test",setup(r){const i=E("a",()=>1),{data:a}=H("b");return(l,t)=>(T(),M("div",null,[S,f("div",null,[D(g(m(i)),1),f("button",{onClick:t[0]||(t[0]=e=>i.value+=1)},"a++")]),f("div",null,[D(g(m(a)),1),f("button",{onClick:t[1]||(t[1]=e=>a.value+=1)},"b++")])]))}},V=A;export{V as _,H as a,j as u};
